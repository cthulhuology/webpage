#!/usr/bin/env escript
%% -*- erlang -*-
%%! -pa $(dirname 0)/ebin -noshell -noinput
%%
%% Copyright 2016 David J. Goehrig <dave@dloh.org>

-record(response, {
	socket, module, function, args, upgrade = false,
	status = 200,
	protocol = <<"HTTP/1.1">>,
	headers = [],
	body = <<>>
}).

%% starts a local node to issue commands from
%% we name these sequentially with system time
%% to avoid colliding with other command processes
connect(Server) ->
	net_kernel:start([ list_to_atom("cmd" ++ integer_to_list(erlang:system_time()) ++ "@localhost"), shortnames ]),
	case net_kernel:connect(Server) of
		false -> 	
			io:format("Failed to connect to ~p~n", [ Server ]),
			erlang:halt(0);
		true -> ok
	end.

%% process takes the command line arugments and performs
%% the associated action
process(Server,["init"]) ->
	io:format("starting ~p~n", [ Server ]),
	process_flag(trap_exit,true),
	case net_kernel:start([Server,shortnames]) of
		{ ok, Pid } ->
			io:format("Started ~p at ~p~n", [ Server, Pid ]),
			connect(Server),
			rpc:call(Server, application,load,[webpage]),
			rpc:call(Server, webpage_database, initialize,[]);
		{ error, Reason } ->
			io:format("Failed to start ~p: ~p~n", [ Server, Reason ]),
			erlang:halt(1)
	end;


process(Server, [ "setup", File ]) ->
	connect(Server),
	{ ok, Config } = file:consult(File),
	io:format("loading config ~p~n", [ Config ]),
	Routes = proplists:get_value(routes, Config),
	[ rpc:call(Server, webpage_router,add,[ Path, Module ]) ||  { Path, Module } <- Routes ],
	Files = proplists:get_value(files, Config),
	[ rpc:call(Server,webpage_file,add,[ Path, Local, Mime ])  || { Path, Local, Mime } <- Files ],
	rpc:call(Server,mnesia,sync_log,[]),
	timer:sleep(5000),
	io:format("done~n");

process(Server,["status"]) ->
	connect(Server),
	io:format("ok~n");

process(Server,["file","add", Path, Filename, Mime]) ->
	connect(Server),
	rpc:call(Server,webpage_router,add, [ Path, [[ webpage_file, []]]]),
	rpc:call(Server,webpage_file,add, [ Path, Filename, binary:list_to_bin(Mime)]);

process(Server,["file","remove", Path]) ->
	connect(Server),
	rpc:call(Server,webpage_router,remove, [ Path ]),
	rpc:call(Server,webpage_file, remove, [ Path ]);

process(Server,["file","get", Path ]) ->
	connect(Server),
	#response{ body = Body } = rpc:call(Server,webpage_file, get, [ Path ]),
	io:format("~s~n", [ Body ]);

process(Server,["file","list"]) ->
	connect(Server),
	Files = rpc:call(Server,webpage_file, list, []),
	io:format("~p~n", [ Files ]);

process(Server,["route","list"]) ->
	connect(Server),
	Res = rpc:call(Server,webpage_router,paths,[]),
	io:format("~p~n",[Res]);

process(Server,["route","add",Path,Module,Args]) ->
	connect(Server),
	Bin = binary:list_to_bin(Args),
	io:format("Got json ~p~n", [ Bin ]),
	Terms = json:decode(Bin),
	io:format("Tems are ~p~n", [ Terms ]),
	rpc:call(Server,webpage_router,add, [ Path, [[ Module, Terms ]] ]);

process(Server,[ "route","get", Path ]) ->
	connect(Server),
	List = rpc:call(Server,webpage_router,route, [Path]),
	io:format("~p~n", [ List ]);

process(Server,["observer"]) ->
	connect(Server),
	rpc:call(Server,observer,start,[]);

process(Server,["console"]) ->
	connect(Server),
	process_flag(trap_exit,true),
	Shell = user_drv:start(['tty_sl -c -e',{Server,shell,start,[]}]),
	true = erlang:link(Shell),
	receive
		{ 'EXIT', Shell, _ } -> ok
	end,
	erlang:halt(0);

process(Server,["start"]) ->
	process_flag(trap_exit,true),
	net_kernel:start([ Server, shortnames ]),
	connect(Server),
	rpc:call(Server,mnesia,start,[]),
	rpc:call(Server,application,load,[webpage]),
	rpc:call(Server,webpage,start,[]),
	receive
		'EXIT' -> 
			io:format("done~n"),
			erlang:halt(0)
	end;

process(Server,["stop"]) ->
	connect(Server),
	rpc:call(Server, mnesia, stop, []),
	rpc:call(Server, erlang, halt, []);

process(_Server,_) ->
	io:format("
usage: webpage [start|stop|status|console|observer|init|route|file]
	start [node]			- start a new node
	stop [node]			- stop a node
	status [node]			- return the status of a node
	console [node]			- connects a console to a node
	observer [node]			- run the observer on a node
	init [node] 			- initialize webpage database
	setup [node] file		- load a setup file on a node
	route [node] [list|add|remove|get]	
		list 			- list all routes by path
		add path module args	- add a MFA at a path
		remove path		- remove a MFA for path
		get path		- get the MFA for path
	file [node] [list|add|remove|get]
		list			- list all files by path
		add path file mime	- add a file at path with mime
		remove path		- remove a file at path
").

%% Loads a configuration file from our home base
%%
load_config(Home) ->
	case file:consult(Home ++ "/.webpage") of 
		{ok, Config } -> 
			Config;
		_ ->
			io:format("Please create a ~s/.webpage configuration file~n", [ Home ]), halt(0)
	end.

set_cookie(Config) ->
	case proplists:get_value(cookie,Config) of
		undefined ->
			ok;
		Cookie ->
			erlang:set_cookie(node(),Cookie)
	end.

find_server([]) ->
	none;
find_server([Host|_Args]) ->
	case string:tokens(Host,"@") of
		[ _Name , _Host ] -> Host;
		_ -> none
	end.

find_host(Config,[])->
	Host = proplists:get_value(host,Config),
	case Host of
		undefined ->
			io:format("Please set host in ~~/.botbop~n"), 
			halt(1);
		Host ->
			{ Host, [] }
	end;
find_host(Config,[ _A | As ] = Args) ->
	Server = find_server(Args),
	case { Server, proplists:get_value(host,Config) } of
		{ none, undefined } ->
			io:format("Please set host in ~~/.webpage~n"), 
			halt(1);
		{ Server, undefined } ->
			{ list_to_atom(Server), As };
		{ none, Host } ->
			{ Host, Args };
		{ Server, _Host } ->
			{ Server, As }
	end.

main(Args) ->
	Home = os:getenv("HOME"),
	Config = load_config(Home),
	{ Host, Args2 } = find_host(Config,Args),
	ok = set_cookie(Config),
	io:format("Connecting to ~p~n", [ Host ]),
	process(Host,Args2).
